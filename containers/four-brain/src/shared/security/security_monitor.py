"""
Security Monitoring System for Four-Brain System v2
Real-time security monitoring with threat detection and alerting

Created: 2025-07-30 AEST
Purpose: Monitor system security events and detect potential threats
"""

import asyncio
import json
import logging
import time
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set, Callable
from dataclasses import dataclass, asdict
from enum import Enum
from collections import defaultdict, deque
import redis.asyncio as aioredis

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ThreatLevel(Enum):
    """Threat severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class EventType(Enum):
    """Security event types"""
    LOGIN_ATTEMPT = "login_attempt"
    LOGIN_FAILURE = "login_failure"
    PERMISSION_DENIED = "permission_denied"
    SUSPICIOUS_ACTIVITY = "suspicious_activity"
    BRUTE_FORCE = "brute_force"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_ACCESS = "data_access"
    SYSTEM_CHANGE = "system_change"
    ANOMALY_DETECTED = "anomaly_detected"

@dataclass
class SecurityEvent:
    """Security event data structure"""
    event_id: str
    event_type: EventType
    threat_level: ThreatLevel
    user_id: str
    username: str
    ip_address: str
    user_agent: str
    resource: str
    action: str
    timestamp: datetime
    details: Dict[str, Any]
    session_id: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for storage"""
        data = asdict(self)
        data['event_type'] = self.event_type.value
        data['threat_level'] = self.threat_level.value
        data['timestamp'] = self.timestamp.isoformat()
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SecurityEvent':
        """Create from dictionary"""
        data['event_type'] = EventType(data['event_type'])
        data['threat_level'] = ThreatLevel(data['threat_level'])
        data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        return cls(**data)

@dataclass
class ThreatPattern:
    """Threat detection pattern"""
    pattern_id: str
    name: str
    description: str
    event_types: List[EventType]
    conditions: Dict[str, Any]
    threat_level: ThreatLevel
    action: str
    enabled: bool

@dataclass
class SecurityAlert:
    """Security alert generated by monitoring"""
    alert_id: str
    pattern_id: str
    threat_level: ThreatLevel
    title: str
    description: str
    affected_user: str
    affected_resource: str
    events: List[SecurityEvent]
    timestamp: datetime
    acknowledged: bool = False
    resolved: bool = False

class SecurityMonitor:
    """
    Comprehensive security monitoring system
    
    Features:
    - Real-time security event processing
    - Threat pattern detection
    - Anomaly detection
    - Automated alerting
    - Security metrics collection
    - Incident correlation
    - Threat intelligence integration
    """
    
    def __init__(self, redis_url: str = "redis://localhost:6379/7"):
        self.redis_url = redis_url
        self.redis_client = None
        
        # Event processing
        self.event_queue = asyncio.Queue()
        self.event_history = deque(maxlen=10000)  # Keep last 10k events
        
        # Threat detection patterns
        self.threat_patterns = self._initialize_threat_patterns()
        
        # User behavior tracking
        self.user_baselines: Dict[str, Dict[str, Any]] = {}
        self.ip_reputation: Dict[str, Dict[str, Any]] = {}
        
        # Alert management
        self.active_alerts: Dict[str, SecurityAlert] = {}
        self.alert_callbacks: List[Callable] = []
        
        # Security metrics
        self.metrics = {
            'events_processed': 0,
            'threats_detected': 0,
            'alerts_generated': 0,
            'false_positives': 0,
            'blocked_attempts': 0,
            'anomalies_detected': 0
        }
        
        # Configuration
        self.config = {
            'event_retention_days': 30,
            'alert_retention_days': 90,
            'anomaly_threshold': 0.8,
            'brute_force_threshold': 5,
            'brute_force_window_minutes': 15,
            'suspicious_activity_threshold': 10
        }
        
        logger.info("🔍 Security Monitor initialized")
    
    async def initialize(self):
        """Initialize Redis connection and start monitoring tasks"""
        try:
            self.redis_client = aioredis.from_url(self.redis_url)
            await self.redis_client.ping()
            
            # Load existing data
            await self._load_user_baselines()
            await self._load_active_alerts()
            
            # Start background tasks
            asyncio.create_task(self._process_events())
            asyncio.create_task(self._cleanup_old_data())
            asyncio.create_task(self._update_threat_intelligence())
            
            logger.info("✅ Security Monitor Redis connection established")
            
        except Exception as e:
            logger.error(f"❌ Failed to initialize Security Monitor: {e}")
            raise
    
    async def log_security_event(self, event_type: EventType, user_id: str, username: str,
                                ip_address: str, user_agent: str, resource: str, action: str,
                                details: Dict[str, Any], session_id: Optional[str] = None):
        """Log a security event for monitoring"""
        try:
            # Generate event ID
            event_id = hashlib.sha256(
                f"{event_type.value}:{user_id}:{ip_address}:{time.time()}".encode()
            ).hexdigest()[:16]
            
            # Determine threat level
            threat_level = self._assess_threat_level(event_type, details)
            
            # Create security event
            event = SecurityEvent(
                event_id=event_id,
                event_type=event_type,
                threat_level=threat_level,
                user_id=user_id,
                username=username,
                ip_address=ip_address,
                user_agent=user_agent,
                resource=resource,
                action=action,
                timestamp=datetime.now(),
                details=details,
                session_id=session_id
            )
            
            # Queue for processing
            await self.event_queue.put(event)
            
            logger.debug(f"🔍 Security event logged: {event_type.value} for user {username}")
            
        except Exception as e:
            logger.error(f"❌ Failed to log security event: {e}")
    
    async def _process_events(self):
        """Background task to process security events"""
        while True:
            try:
                # Get event from queue
                event = await self.event_queue.get()
                
                # Store event
                await self._store_event(event)
                self.event_history.append(event)
                self.metrics['events_processed'] += 1
                
                # Check threat patterns
                await self._check_threat_patterns(event)
                
                # Update user baseline
                await self._update_user_baseline(event)
                
                # Check for anomalies
                await self._check_anomalies(event)
                
                # Update IP reputation
                await self._update_ip_reputation(event)
                
            except Exception as e:
                logger.error(f"❌ Event processing error: {e}")
                await asyncio.sleep(1)
    
    async def _check_threat_patterns(self, event: SecurityEvent):
        """Check event against known threat patterns"""
        for pattern in self.threat_patterns.values():
            if not pattern.enabled:
                continue
            
            if event.event_type in pattern.event_types:
                if await self._pattern_matches(pattern, event):
                    await self._generate_alert(pattern, event)
                    self.metrics['threats_detected'] += 1
    
    async def _pattern_matches(self, pattern: ThreatPattern, event: SecurityEvent) -> bool:
        """Check if event matches threat pattern conditions"""
        conditions = pattern.conditions
        
        # Brute force detection
        if pattern.pattern_id == "brute_force":
            return await self._check_brute_force(event)
        
        # Privilege escalation detection
        elif pattern.pattern_id == "privilege_escalation":
            return await self._check_privilege_escalation(event)
        
        # Suspicious activity detection
        elif pattern.pattern_id == "suspicious_activity":
            return await self._check_suspicious_activity(event)
        
        # Time-based anomaly
        elif pattern.pattern_id == "time_anomaly":
            return await self._check_time_anomaly(event)
        
        return False
    
    async def _check_brute_force(self, event: SecurityEvent) -> bool:
        """Check for brute force attack patterns"""
        if event.event_type != EventType.LOGIN_FAILURE:
            return False
        
        # Count recent failures for this user/IP
        window_start = datetime.now() - timedelta(minutes=self.config['brute_force_window_minutes'])
        
        failure_count = 0
        for hist_event in reversed(self.event_history):
            if hist_event.timestamp < window_start:
                break
            
            if (hist_event.event_type == EventType.LOGIN_FAILURE and
                (hist_event.user_id == event.user_id or hist_event.ip_address == event.ip_address)):
                failure_count += 1
        
        return failure_count >= self.config['brute_force_threshold']
    
    async def _check_privilege_escalation(self, event: SecurityEvent) -> bool:
        """Check for privilege escalation attempts"""
        if event.event_type != EventType.PERMISSION_DENIED:
            return False
        
        # Check if user is attempting to access higher privilege resources
        return event.details.get('attempted_privilege_level', 0) > event.details.get('user_privilege_level', 0)
    
    async def _check_suspicious_activity(self, event: SecurityEvent) -> bool:
        """Check for suspicious activity patterns"""
        # Multiple different IPs for same user
        user_ips = set()
        for hist_event in list(self.event_history)[-100:]:  # Check last 100 events
            if hist_event.user_id == event.user_id:
                user_ips.add(hist_event.ip_address)
        
        if len(user_ips) > 5:  # User from more than 5 different IPs recently
            return True
        
        # Rapid successive actions
        recent_actions = 0
        window_start = datetime.now() - timedelta(minutes=5)
        for hist_event in reversed(self.event_history):
            if hist_event.timestamp < window_start:
                break
            if hist_event.user_id == event.user_id:
                recent_actions += 1
        
        return recent_actions > self.config['suspicious_activity_threshold']
    
    async def _check_time_anomaly(self, event: SecurityEvent) -> bool:
        """Check for time-based anomalies"""
        user_baseline = self.user_baselines.get(event.user_id, {})
        if not user_baseline.get('typical_hours'):
            return False
        
        current_hour = event.timestamp.hour
        typical_hours = user_baseline['typical_hours']
        
        # Check if current hour is outside typical usage pattern
        return current_hour not in typical_hours
    
    async def _generate_alert(self, pattern: ThreatPattern, event: SecurityEvent):
        """Generate security alert"""
        try:
            alert_id = hashlib.sha256(
                f"{pattern.pattern_id}:{event.user_id}:{event.ip_address}:{int(time.time())}".encode()
            ).hexdigest()[:16]
            
            # Collect related events
            related_events = [event]
            for hist_event in reversed(list(self.event_history)[-50:]):
                if (hist_event.user_id == event.user_id or 
                    hist_event.ip_address == event.ip_address):
                    related_events.append(hist_event)
                    if len(related_events) >= 10:
                        break
            
            alert = SecurityAlert(
                alert_id=alert_id,
                pattern_id=pattern.pattern_id,
                threat_level=pattern.threat_level,
                title=f"{pattern.name} detected",
                description=f"{pattern.description} - User: {event.username}, IP: {event.ip_address}",
                affected_user=event.user_id,
                affected_resource=event.resource,
                events=related_events,
                timestamp=datetime.now()
            )
            
            # Store alert
            self.active_alerts[alert_id] = alert
            await self._store_alert(alert)
            
            # Notify callbacks
            for callback in self.alert_callbacks:
                try:
                    await callback(alert)
                except Exception as e:
                    logger.error(f"Alert callback error: {e}")
            
            self.metrics['alerts_generated'] += 1
            
            logger.warning(f"🚨 Security alert generated: {alert.title} (ID: {alert_id})")
            
        except Exception as e:
            logger.error(f"❌ Failed to generate alert: {e}")
    
    async def _update_user_baseline(self, event: SecurityEvent):
        """Update user behavior baseline"""
        user_id = event.user_id
        
        if user_id not in self.user_baselines:
            self.user_baselines[user_id] = {
                'typical_hours': set(),
                'typical_ips': set(),
                'typical_resources': set(),
                'activity_count': 0,
                'last_updated': datetime.now()
            }
        
        baseline = self.user_baselines[user_id]
        baseline['typical_hours'].add(event.timestamp.hour)
        baseline['typical_ips'].add(event.ip_address)
        baseline['typical_resources'].add(event.resource)
        baseline['activity_count'] += 1
        baseline['last_updated'] = datetime.now()
        
        # Limit set sizes to prevent memory issues
        if len(baseline['typical_ips']) > 20:
            baseline['typical_ips'] = set(list(baseline['typical_ips'])[-20:])
        if len(baseline['typical_resources']) > 50:
            baseline['typical_resources'] = set(list(baseline['typical_resources'])[-50:])
    
    async def _check_anomalies(self, event: SecurityEvent):
        """Check for behavioral anomalies"""
        user_baseline = self.user_baselines.get(event.user_id)
        if not user_baseline or user_baseline['activity_count'] < 10:
            return  # Need more data for baseline
        
        anomaly_score = 0.0
        
        # Check IP anomaly
        if event.ip_address not in user_baseline['typical_ips']:
            anomaly_score += 0.3
        
        # Check time anomaly
        if event.timestamp.hour not in user_baseline['typical_hours']:
            anomaly_score += 0.2
        
        # Check resource anomaly
        if event.resource not in user_baseline['typical_resources']:
            anomaly_score += 0.3
        
        # Check user agent anomaly (simplified)
        if len(event.user_agent) < 10:  # Suspicious short user agent
            anomaly_score += 0.2
        
        if anomaly_score >= self.config['anomaly_threshold']:
            await self.log_security_event(
                EventType.ANOMALY_DETECTED,
                event.user_id,
                event.username,
                event.ip_address,
                event.user_agent,
                event.resource,
                "anomaly_detection",
                {'anomaly_score': anomaly_score, 'original_event': event.event_type.value}
            )
            self.metrics['anomalies_detected'] += 1
    
    async def _update_ip_reputation(self, event: SecurityEvent):
        """Update IP reputation based on activity"""
        ip = event.ip_address
        
        if ip not in self.ip_reputation:
            self.ip_reputation[ip] = {
                'reputation_score': 0.5,  # Neutral
                'event_count': 0,
                'threat_events': 0,
                'last_seen': datetime.now()
            }
        
        rep = self.ip_reputation[ip]
        rep['event_count'] += 1
        rep['last_seen'] = datetime.now()
        
        # Adjust reputation based on event type
        if event.event_type in [EventType.LOGIN_FAILURE, EventType.PERMISSION_DENIED]:
            rep['threat_events'] += 1
            rep['reputation_score'] = max(0.0, rep['reputation_score'] - 0.1)
        elif event.event_type == EventType.LOGIN_ATTEMPT:
            rep['reputation_score'] = min(1.0, rep['reputation_score'] + 0.01)
    
    def _assess_threat_level(self, event_type: EventType, details: Dict[str, Any]) -> ThreatLevel:
        """Assess threat level for an event"""
        if event_type in [EventType.BRUTE_FORCE, EventType.PRIVILEGE_ESCALATION]:
            return ThreatLevel.HIGH
        elif event_type in [EventType.SUSPICIOUS_ACTIVITY, EventType.ANOMALY_DETECTED]:
            return ThreatLevel.MEDIUM
        elif event_type in [EventType.LOGIN_FAILURE, EventType.PERMISSION_DENIED]:
            return ThreatLevel.LOW
        else:
            return ThreatLevel.LOW
    
    def _initialize_threat_patterns(self) -> Dict[str, ThreatPattern]:
        """Initialize threat detection patterns"""
        return {
            'brute_force': ThreatPattern(
                pattern_id='brute_force',
                name='Brute Force Attack',
                description='Multiple failed login attempts detected',
                event_types=[EventType.LOGIN_FAILURE],
                conditions={'threshold': 5, 'window_minutes': 15},
                threat_level=ThreatLevel.HIGH,
                action='block_ip',
                enabled=True
            ),
            'privilege_escalation': ThreatPattern(
                pattern_id='privilege_escalation',
                name='Privilege Escalation Attempt',
                description='User attempting to access higher privilege resources',
                event_types=[EventType.PERMISSION_DENIED],
                conditions={'privilege_difference': 1},
                threat_level=ThreatLevel.HIGH,
                action='alert_admin',
                enabled=True
            ),
            'suspicious_activity': ThreatPattern(
                pattern_id='suspicious_activity',
                name='Suspicious Activity',
                description='Unusual user behavior detected',
                event_types=[EventType.SUSPICIOUS_ACTIVITY],
                conditions={'activity_threshold': 10},
                threat_level=ThreatLevel.MEDIUM,
                action='monitor',
                enabled=True
            ),
            'time_anomaly': ThreatPattern(
                pattern_id='time_anomaly',
                name='Time-based Anomaly',
                description='User activity outside typical hours',
                event_types=[EventType.DATA_ACCESS, EventType.SYSTEM_CHANGE],
                conditions={'deviation_threshold': 0.8},
                threat_level=ThreatLevel.LOW,
                action='log',
                enabled=True
            )
        }
    
    async def _store_event(self, event: SecurityEvent):
        """Store security event in Redis"""
        if self.redis_client:
            try:
                key = f"security_event:{event.event_id}"
                data = json.dumps(event.to_dict())
                ttl = self.config['event_retention_days'] * 86400
                await self.redis_client.setex(key, ttl, data)
            except Exception as e:
                logger.error(f"Failed to store security event: {e}")
    
    async def _store_alert(self, alert: SecurityAlert):
        """Store security alert in Redis"""
        if self.redis_client:
            try:
                key = f"security_alert:{alert.alert_id}"
                data = json.dumps(asdict(alert), default=str)
                ttl = self.config['alert_retention_days'] * 86400
                await self.redis_client.setex(key, ttl, data)
            except Exception as e:
                logger.error(f"Failed to store security alert: {e}")
    
    async def _load_user_baselines(self):
        """Load user baselines from Redis"""
        # Implementation for loading user baselines
        pass
    
    async def _load_active_alerts(self):
        """Load active alerts from Redis"""
        # Implementation for loading active alerts
        pass
    
    async def _cleanup_old_data(self):
        """Background task to cleanup old data"""
        while True:
            try:
                await asyncio.sleep(3600)  # Run every hour
                
                # Cleanup old events from memory
                cutoff_time = datetime.now() - timedelta(hours=24)
                self.event_history = deque(
                    [e for e in self.event_history if e.timestamp > cutoff_time],
                    maxlen=10000
                )
                
                # Cleanup old IP reputation data
                cutoff_time = datetime.now() - timedelta(days=7)
                old_ips = [
                    ip for ip, data in self.ip_reputation.items()
                    if data['last_seen'] < cutoff_time
                ]
                for ip in old_ips:
                    del self.ip_reputation[ip]
                
                logger.info("🧹 Security monitor data cleanup completed")
                
            except Exception as e:
                logger.error(f"❌ Cleanup error: {e}")
    
    async def _update_threat_intelligence(self):
        """Background task to update threat intelligence"""
        while True:
            try:
                await asyncio.sleep(3600 * 6)  # Run every 6 hours
                
                # Update threat patterns based on recent activity
                # This is a placeholder for threat intelligence integration
                
                logger.info("🔍 Threat intelligence updated")
                
            except Exception as e:
                logger.error(f"❌ Threat intelligence update error: {e}")
    
    def add_alert_callback(self, callback: Callable):
        """Add callback for security alerts"""
        self.alert_callbacks.append(callback)
    
    async def get_security_metrics(self) -> Dict[str, Any]:
        """Get security monitoring metrics"""
        return {
            'metrics': self.metrics.copy(),
            'active_alerts': len(self.active_alerts),
            'monitored_users': len(self.user_baselines),
            'ip_reputation_entries': len(self.ip_reputation),
            'threat_patterns': len(self.threat_patterns),
            'event_history_size': len(self.event_history),
            'timestamp': datetime.now().isoformat()
        }

# Global security monitor instance
security_monitor = SecurityMonitor()

async def initialize_security_monitor():
    """Initialize the global security monitor"""
    await security_monitor.initialize()

if __name__ == "__main__":
    # Test the security monitor
    async def test_security_monitor():
        await initialize_security_monitor()
        
        # Log test events
        await security_monitor.log_security_event(
            EventType.LOGIN_ATTEMPT,
            "test_user",
            "testuser",
            "127.0.0.1",
            "Test Agent",
            "login",
            "authenticate",
            {"success": True}
        )
        
        # Wait for processing
        await asyncio.sleep(1)
        
        # Get metrics
        metrics = await security_monitor.get_security_metrics()
        print(f"Security metrics: {metrics}")
    
    asyncio.run(test_security_monitor())
